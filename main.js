// Generated by CoffeeScript 1.6.2
var EventEmitter, PACKETS, RESPONSES, SrcDS, dgram, packet,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

dgram = require("dgram");

packet = require("packet");

EventEmitter = require('events').EventEmitter;

PACKETS = {
  info: new Buffer(["0xff", "0xff", "0xff", "0xff", "0x54", "0x53", "0x6f", "0x75", "0x72", "0x63", "0x65", "0x20", "0x45", "0x6e", "0x67", "0x69", "0x6e", "0x65", "0x20", "0x51", "0x75", "0x65", "0x72", "0x79", "0x00"]),
  playerChallenge: new Buffer(["0xff", "0xff", "0xff", "0xff", "0x55", "0xff", "0xff", "0xff", "0xff"])
};

RESPONSES = {
  header: "x32, b8|chr() => type",
  info: "b8 => version,\nb8z|utf8() => serverName,\nb8z|utf8() => map,\nb8z|utf8() => gameType,\nb8z|utf8() => gameName,\nl16 => appID,\nb8 => numPlayers,\nb8 => maxPlayers,\nb8 => numBots,\nb8|chr() => dedicated,\nb8|chr() => os,\nb8 => password,\nb8 => secure,\nb8z|utf8() => gameVersion",
  challenge: "-l32 => challenge ",
  playerStart: "b8 => numPlayers",
  player: "b8 => index,\nb8z|utf8() => name,\n-l32 => score,\nb32f => duration"
};

SrcDS = (function(_super) {
  __extends(SrcDS, _super);

  function SrcDS(ip, port, options) {
    var _base, _ref,
      _this = this;

    if (options == null) {
      options = {};
    }
    this.onInfo = __bind(this.onInfo, this);
    this.onPlayer = __bind(this.onPlayer, this);
    this.onPlayerStart = __bind(this.onPlayerStart, this);
    this.onChallenge = __bind(this.onChallenge, this);
    this.onMsg = __bind(this.onMsg, this);
    if (this === global) {
      return new SrcDS(ip, port, options);
    }
    _ref = [ip, port, options], this.ip = _ref[0], this.port = _ref[1], this.options = _ref[2];
    this.client = dgram.createSocket('udp4');
    this.parser = new packet.Parser();
    this.parser._transforms.chr = function(parsing, field, value) {
      if (parsing) {
        return String.fromCharCode(value);
      } else {
        return value.charCodeAt();
      }
    };
    this.client.on('message', function(msg, rinfo) {
      _this.ip = rinfo.address;
      _this.port = rinfo.port;
      _this.parser.extract(RESPONSES.header, function(msg) {
        return _this.onMsg(msg);
      });
      return _this.parser.parse(msg);
    });
    (_base = this.options).timeout || (_base.timeout = 10000);
  }

  SrcDS.prototype.send = function(packet, cb) {
    var _this = this;

    if (cb == null) {
      cb = function() {};
    }
    return this.client.send(packet, 0, packet.length, this.port, this.ip, function(err) {
      var msgcb, timeout;

      if (err) {
        return cb(err);
      } else {
        timeout = null;
        msgcb = function(msg) {
          clearTimeout(timeout);
          return cb(null, msg);
        };
        _this.once('message', msgcb);
        return timeout = setTimeout(function() {
          _this.removeListener('message', msgcb);
          return cb(new Error("Request timed out"));
        }, _this.options.timeout);
      }
    });
  };

  SrcDS.prototype.info = function(cb) {
    return this.send(PACKETS.info, cb);
  };

  SrcDS.prototype.player = function(cb) {
    return this.send(PACKETS.playerChallenge, cb);
  };

  SrcDS.prototype.onMsg = function(msg) {
    var _this = this;

    if (msg.type === 'I') {
      return this.parser.extract(RESPONSES.info, function(msg) {
        return _this.onInfo(msg);
      });
    } else if (msg.type === 'D') {
      return this.parser.extract(RESPONSES.playerStart, function(msg) {
        return _this.onPlayerStart(msg);
      });
    } else if (msg.type === 'A') {
      return this.parser.extract(RESPONSES.challenge, function(msg) {
        return _this.onChallenge(msg);
      });
    }
  };

  SrcDS.prototype.onChallenge = function(msg) {
    var playerQuery;

    playerQuery = new Buffer(9);
    PACKETS.playerChallenge.copy(playerQuery, 0, 0, 5);
    playerQuery.writeInt32LE(msg.challenge, 5);
    return this.client.send(playerQuery, 0, playerQuery.length, this.port, this.ip);
  };

  SrcDS.prototype.onPlayerStart = function(msg) {
    var _this = this;

    if (msg.numPlayers > 0) {
      return this.parser.extract(RESPONSES.player, function(next_msg) {
        return _this.onPlayer(next_msg, 1, msg.numPlayers, []);
      });
    } else {
      return this.emit("message", {
        ip: this.ip,
        port: this.port,
        numPlayers: msg.numPlayers,
        players: []
      });
    }
  };

  SrcDS.prototype.onPlayer = function(msg, cur, max, players) {
    var _this = this;

    players.push(msg);
    if (cur >= max) {
      return this.emit("message", {
        ip: this.ip,
        port: this.port,
        numPlayers: max,
        players: players
      });
    } else {
      return this.parser.extract(RESPONSES.player, function(msg) {
        return _this.onPlayer(msg, cur + 1, max, players);
      });
    }
  };

  SrcDS.prototype.onInfo = function(msg) {
    var decoded;

    decoded = msg;
    decoded.ip = this.ip;
    decoded.port = this.port;
    switch (decoded.os) {
      case "l":
        decoded.os = "Linux";
        break;
      case "w":
        decoded.os = "Windows";
    }
    switch (decoded.dedicated) {
      case "d":
        decoded.dedicated = "dedicated";
        break;
      case "l":
        decoded.dedicated = "listen";
        break;
      case "p":
        decoded.dedicated = "SourceTV";
    }
    decoded.pw = decoded.pw === 1;
    decoded.secure = decoded.secure === 1;
    return this.emit("message", decoded);
  };

  SrcDS.prototype.close = function() {
    return this.client.close();
  };

  return SrcDS;

})(EventEmitter);

module.exports = SrcDS;
